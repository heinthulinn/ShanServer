// ===== gameFlow.js =====
const { broadcastToTable } = require("../ws/sender");
const { tables } = require("../state/tables");
let startGameFn = null;

function registerStartGame(fn) {
  startGameFn = fn;
}

function autoStart(table) {
  console.log("ðŸ§ª autoStart()", {
    roundInProgress: table.roundInProgress,
    countdownInterval: !!table.countdownInterval,
    betInterval: !!table.betInterval,
    ready: table.players.map(p => p.ready)
  });
  
  if (!table || table.players.length === 0) return;
  if (table.roundInProgress) return;
  if (table.betInterval) return;

  const realPlayers = table.players.filter(p => !p.isAi);
  if (realPlayers.length < 1) return;
  if (table.players.length < 3) return;
  if (!realPlayers.every(p => p.ready)) return;

  console.log(`ðŸ”¥ TABLE READY â†’ STARTING GAME From GameFlow" table=${table.tableId} t=${Date.now()}`);
  startGameForTable(table);
}

function assignDealerForRound(table) {
  if (!table.rtpStats) return;

  const players = table.players.filter(p => !p.waiting);
  if (!players.length) return;

  const minDealerBalance = (table.minBet || table.defaultBet) * 10;

  // clear old dealer
  players.forEach(p => p.isDealer = false);

  let startIndex = table.rtpStats.dealerIndex || 0;
  let dealer = null;

  for (let i = 0; i < players.length; i++) {
    const index = (startIndex + i) % players.length;
    const candidate = players[index];

    if (candidate.balance >= minDealerBalance) {
      dealer = candidate;
      table.rtpStats.dealerIndex = index; // lock dealer index
      break;
    }
  }

  if (!dealer) {
    console.log("âŒ NO VALID DEALER (insufficient balance)");
    return;
  }

  dealer.isDealer = true;

  console.log(`ðŸƒ DEALER ASSIGNED â†’ ${dealer.username} because of enough he has 10 times of min bet of ${table.tableName}`);

  broadcastToTable(table.tableId, {
    type: "game:dealer:assigned",
    dealer: {
      username: dealer.username,
      seatId: dealer.seatId
    }
  });
}


function rotateDealer(table) {
  const activePlayers = table.players.filter(p => !p.waiting);
  if (!activePlayers.length) return;

  if (typeof table.rtpStats.dealerIndex !== "number") {
    table.rtpStats.dealerIndex = 0;
  } else {
    table.rtpStats.dealerIndex =
      (table.rtpStats.dealerIndex + 1) % activePlayers.length;
  }

  console.log(`ðŸ”„ DEALER ROTATED â†’ index ${table.rtpStats.dealerIndex}`);
}




function startGameForTable(table) {
  if (!table || table.gameInProgress || table.countdownInterval) return;
  table.roundInProgress = true;   // âœ… ADD THIS
  table.gameInProgress = true;
  //table.dealing = false;
  assignDealerForRound(table);
  table.countdown = 3;

  broadcastToTable(table.tableId, {
    type: "game:countdown",
    seconds: table.countdown
  });

  table.countdownInterval = setInterval(() => {
    table.countdown--;

    if (table.countdown > 0) {
      broadcastToTable(table.tableId, {
        type: "game:countdown",
        seconds: table.countdown
      });
    } else {
      clearInterval(table.countdownInterval);
      table.countdownInterval = null;

      broadcastToTable(table.tableId, {
        type: "game:countdown",
        seconds: 0
      });

      console.log(`[COUNTDOWN FINISHED â†’ START BET] table=${table.tableId} t=${Date.now()}`);

      startBettingPhase(table);
    }
  }, 1000);
}

function generateAIBet(table,player)
{
  const minBet = table.minBet || table.defaultBet;
  const maxBet = table.maxBet || table.defaultBet*10;

  const steps = Math.floor((maxBet-minBet)/100)+1;
  const randomStep = Math.floor(Math.random()*steps);

  let bet = minBet+randomStep*100;
  bet = Math.min(bet,player.balance);
  return bet;
}

function finializeBets(table)
{
  table.players.forEach(p=>{
    if(p.isDealer) return; // skip dealer
    if(!p.currentBet || p.currentBet<=0)
    {
      if(p.isAi)
      {
        p.currentBet = generateAIBet(table,p);
        console.log(`Ai auto bet| ${p.username}= ${p.currentBet}`);
      }
      else
      {
        p.currentBet = table.defaultBet;
        console.log(`Players auto bet|${p.username}=${p.currentBet}`);
      }
    }
  })
}

function startBettingPhase(table) {
  table.betTime = 5;

  console.log(`[BET START] table=${table.tableId} t=${Date.now()} sec=${table.betTime}`);

  // Reset bets for all playes
  table.players.forEach(p=>{p.currentBet =0;});
  broadcastToTable(table.tableId,{type:"game:bet:start", seconds: table.betTime});
  // Place bet for Ai players
  table.players.forEach(p=>{if(p.isAi && !p.isDealer)
  {
    p.currentBet  = generateAIBet(table,p);
    console.log(`ðŸ¤– AI BET | ${p.username} = ${p.currentBet} (table ${table.tableName})`);
  }
  });

  // Send Ai bets to unity
  broadcastToTable(table.tableId,{
    type: "table:bet:update",
    players: table.players.map(p=>({username:p.username,betAmount:p.currentBet})),
    total: table.players.reduce((s,p)=> s+(p.currentBet||0),0)
  });

  table.betInterval = setInterval(() => {
    table.betTime--;
  
    broadcastToTable(table.tableId, {
      type: "game:bet:timer",
      seconds: table.betTime
    });
  
    if (table.betTime <= 0) {
      clearInterval(table.betInterval);
      table.betInterval = null;
  
      console.log(`[BET FINISHED â†’ DEAL START] table=${table.tableId} t=${Date.now()}`);
  
      finializeBets(table);
  
      broadcastToTable(table.tableId, {
        type: "table:bet:final",
        players: table.players.map(p => ({
          username: p.username,
          betAmount: p.currentBet
        })),
        total: table.players.reduce((s, p) => s + (p.currentBet || 0), 0)
      });
  
      broadcastToTable(table.tableId, { type: "game:bet:end" });
  
      setTimeout(() => {
        if (startGameFn) {
          startGameFn(null, { tableId: table.tableId });
        }
  
        broadcastToTable(table.tableId, {
          type: "game:deal:start",
          roundId: table.roundId
        });
        rotateDealer(table); // âœ… THIS IS THE CORRECT PLACE
  
       // table.roundInProgress = false;
       // table.gameInProgress = false; // ðŸ”¥ SEE NEXT POINT
      }, 1000);
    }
  }, 1000);
  
}
module.exports = {
  autoStart,
  startGameForTable,
  startBettingPhase,
  registerStartGame
};

