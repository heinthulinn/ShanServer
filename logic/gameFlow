// ===== gameFlow.js =====
const { broadcastToTable } = require("../ws/sender");
const { tables } = require("../state/tables");
let startGameFn = null;

function registerStartGame(fn) {
  startGameFn = fn;
}

function autoStart(table) {
  console.log("ðŸ§ª autoStart()", {
    roundInProgress: table.roundInProgress,
    countdownInterval: !!table.countdownInterval,
    betInterval: !!table.betInterval,
    ready: table.players.map(p => p.ready)
  });

  if (!table || table.players.length === 0) return;
  if (table.roundInProgress || table.betInterval) return;

  const realPlayers = table.players.filter(p => !p.isAi);
  if (realPlayers.length < 1) return;
  if (table.players.length < 3) return; 
  if (!realPlayers.every(p => p.ready)) return;

  console.log(`ðŸ”¥ TABLE READY â†’ STARTING SHAN GAME | table=${table.tableId}`);
  startGameForTable(table);
}

function assignDealerForRound(table) {
  if (!table.rtpStats) return;

  const activePlayers = table.players.filter(p => !p.waiting);
  if (!activePlayers.length) return;

  // Shan Rule: 10x Min Bet required (e.g., 3,000 bet needs 30,000 balance)
  const minDealerBalance = (table.minBet || table.defaultBet) * 10;

  // Check if current dealer finished 3 rounds of "Warning" (á€á€™á€ºá€á€­á€”á€º)
  if (table.isWarningActive && table.dealerWarningRounds >= 3) {
      console.log("ðŸ›‘ Dealer finished 3-round warning period. Rotating...");
      table.isWarningActive = false;
      table.dealerWarningRounds = 0;
      table.dealerStartBalance = 0;
      rotateDealer(table); 
  }

  activePlayers.forEach(p => p.isDealer = false);

  let startIndex = table.rtpStats.dealerIndex || 0;
  let dealer = null;

  for (let i = 0; i < activePlayers.length; i++) {
    const index = (startIndex + i) % activePlayers.length;
    const candidate = activePlayers[index];

    if (candidate.balance >= minDealerBalance) {
      dealer = candidate;
      table.rtpStats.dealerIndex = index;
      break;
    }
  }

  if (!dealer) {
    console.log("âŒ NO VALID DEALER (Insufficient balance for 10x rule)");
    return;
  }

  dealer.isDealer = true;

  // Initialize tracking for Warning (á€á€™á€ºá€á€­á€”á€º)
  if (table.currentDealerName !== dealer.username) {
      table.currentDealerName = dealer.username;
      table.dealerStartBalance = dealer.balance;
      table.isWarningActive = false;
      table.dealerWarningRounds = 0;
  }

  // Check for Triple Profit Warning
  if (!table.isWarningActive && dealer.balance >= (table.dealerStartBalance * 3)) {
      table.isWarningActive = true;
      console.log(`âš ï¸ á€á€™á€ºá€á€­á€”á€º! ${dealer.username} tripled balance.`);
      broadcastToTable(table.tableId, { type: "game:dealer:warning", dealer: dealer.username });
  }

  if (table.isWarningActive) table.dealerWarningRounds++;

  console.log(`ðŸƒ DEALER ASSIGNED â†’ ${dealer.username}`);

  broadcastToTable(table.tableId, {
    type: "game:dealer:assigned",
    dealer: { 
      username: dealer.username, 
      seatId: dealer.seatId,
      isWarning: table.isWarningActive 
    }
  });
}

function rotateDealer(table) {
  const activePlayers = table.players.filter(p => !p.waiting);
  if (!activePlayers.length) return;

  if (typeof table.rtpStats.dealerIndex !== "number") {
    table.rtpStats.dealerIndex = 0;
  } else {
    table.rtpStats.dealerIndex = (table.rtpStats.dealerIndex + 1) % activePlayers.length;
  }
  console.log(`ðŸ”„ DEALER ROTATED â†’ index ${table.rtpStats.dealerIndex}`);
}

function startGameForTable(table) {
  if (!table || table.gameInProgress || table.countdownInterval) return;
  
  table.roundInProgress = true; 
  table.gameInProgress = true;
  
  assignDealerForRound(table);
  
  table.countdown = 3;
  broadcastToTable(table.tableId, { type: "game:countdown", seconds: table.countdown });

  table.countdownInterval = setInterval(() => {
    table.countdown--;
    if (table.countdown > 0) {
      broadcastToTable(table.tableId, { type: "game:countdown", seconds: table.countdown });
    } else {
      clearInterval(table.countdownInterval);
      table.countdownInterval = null;
      
      broadcastToTable(table.tableId, { type: "game:countdown", seconds: 0 });
      console.log(`[COUNTDOWN FINISHED] table=${table.tableId}`);
      startBettingPhase(table);
    }
  }, 1000);
}

function generateAIBet(table, player) {
  const minBet = table.minBet || table.defaultBet;
  const maxBet = table.maxBet || table.defaultBet * 10;
  const steps = Math.floor((maxBet - minBet) / 100) + 1;
  const randomStep = Math.floor(Math.random() * steps);
  let bet = minBet + randomStep * 100;
  return Math.min(bet, player.balance);
}

function finializeBets(table) {
  table.players.forEach(p => {
    if (p.isDealer) return;
    if (!p.currentBet || p.currentBet <= 0) {
      p.currentBet = p.isAi ? generateAIBet(table, p) : table.defaultBet;
    }
  });
}

function startBettingPhase(table) {
  table.betTime = 5;
  table.players.forEach(p => { p.currentBet = 0; });
  
  broadcastToTable(table.tableId, { type: "game:bet:start", seconds: table.betTime });

  table.players.forEach(p => {
    if (p.isAi && !p.isDealer) p.currentBet = generateAIBet(table, p);
  });

  broadcastToTable(table.tableId, {
    type: "table:bet:update",
    players: table.players.map(p => ({ username: p.username, betAmount: p.currentBet })),
    total: table.players.reduce((s, p) => s + (p.currentBet || 0), 0)
  });

  table.betInterval = setInterval(() => {
    table.betTime--;
    broadcastToTable(table.tableId, { type: "game:bet:timer", seconds: table.betTime });

    if (table.betTime <= 0) {
      clearInterval(table.betInterval);
      table.betInterval = null;
      finializeBets(table);

      broadcastToTable(table.tableId, {
        type: "table:bet:final",
        players: table.players.map(p => ({ username: p.username, betAmount: p.currentBet })),
        total: table.players.reduce((s, p) => s + (p.currentBet || 0), 0)
      });

      broadcastToTable(table.tableId, { type: "game:bet:end" });

      setTimeout(() => {
        // âœ… CRITICAL FIX: Reset roundInProgress so Unity hides the Countdown UI
        table.roundInProgress = false; 

        if (startGameFn) startGameFn(null, { tableId: table.tableId });
        
        broadcastToTable(table.tableId, { type: "game:deal:start", roundId: table.roundId });
        
        if (!table.isWarningActive) rotateDealer(table); 
      }, 1000);
    }
  }, 1000);
}

module.exports = { autoStart, startGameForTable, startBettingPhase, registerStartGame };