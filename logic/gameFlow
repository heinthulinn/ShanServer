// ===== gameFlow.js =====
const { broadcastToTable } = require("../ws/sender");
const { tables } = require("../state/tables");
let startGameFn = null;

function registerStartGame(fn) {
  startGameFn = fn;
}

function autoStart(table) {
  console.log("ðŸ§ª autoStart()", {
    roundInProgress: table.roundInProgress,
    countdownInterval: !!table.countdownInterval,
    betInterval: !!table.betInterval,
    ready: table.players.map(p => p.ready)
  });

  if (!table || table.players.length === 0) return;
  if (table.roundInProgress || table.betInterval) return;

  const realPlayers = table.players.filter(p => !p.isAi);
  if (realPlayers.length < 1) return;
  if (table.players.length < 3) return; 
  if (!realPlayers.every(p => p.ready)) return;

  console.log(`ðŸ”¥ TABLE READY â†’ STARTING SHAN GAME | table=${table.tableId}`);
  startGameForTable(table);
}

function assignDealerForRound(table) {
  if (!table.rtpStats) return;

  const activePlayers = table.players.filter(p => !p.waiting);
  if (!activePlayers.length) return;

  const minBet = table.minBet || table.defaultBet;
  const buyInAmount = minBet * 10;

  // --- ðŸ”„ ROTATION LOGIC ---
  table.dealerRoundsPlayed = table.dealerRoundsPlayed || 0;

  const warningExpired = table.isWarningActive && table.dealerWarningRounds >= 3;
  const normalSessionExpired = !table.isWarningActive && table.dealerRoundsPlayed >= 5; // Set to 5 for standard play
  const isBroke = table.bankerPot <= 0 && table.currentDealerName;

  if (warningExpired || normalSessionExpired || isBroke) {
      console.log(`ðŸ”„ Rotating Dealer: Reason(Warning:${warningExpired}, Normal:${normalSessionExpired}, Broke:${isBroke})`);
      finalizeBankerSession(table);
      table.dealerRoundsPlayed = 0; 
  }

  // --- DEALER SELECTION ---
  if (!table.bankerPot || table.bankerPot <= 0) {
      if (table.currentDealerName) finalizeBankerSession(table);

      let startIndex = table.rtpStats.dealerIndex || 0;
      let dealerFound = false;

      for (let i = 0; i < activePlayers.length; i++) {
        const index = (startIndex + i) % activePlayers.length;
        const candidate = activePlayers[index];

        if (candidate.balance >= buyInAmount) {
          candidate.balance -= buyInAmount;
          table.bankerPot = buyInAmount;
          table.dealerStartPot = buyInAmount;
          table.currentDealerName = candidate.username;
          table.rtpStats.dealerIndex = index;
          
          table.isWarningActive = false;
          table.dealerWarningRounds = 0;
          table.dealerRoundsPlayed = 0; 
          dealerFound = true;
          break;
        }
      }
      if (!dealerFound) return;
  }

  // Set flags
  table.players.forEach(p => p.isDealer = (p.username === table.currentDealerName));
  const dealer = table.players.find(p => p.isDealer);
  dealer.bankerFund = table.bankerPot;

  // 1. Increment standard rounds
  table.dealerRoundsPlayed++;

  // 2. ðŸ”¥ HANDLE WARNING (3X Profit)
  if (!table.isWarningActive && table.bankerPot >= (table.dealerStartPot * 3)) {
      table.isWarningActive = true;
      table.dealerWarningRounds = 0; 
  }

  // 3. Increment and Broadcast Warning if active
  if (table.isWarningActive) {
    table.dealerWarningRounds++; 
    
    broadcastToTable(table.tableId, { 
        type: "game:dealer:warning", 
        dealer: dealer.username,
        currentWarningRound: table.dealerWarningRounds, 
        totalWarningRounds: 3 
    });
  }

  // 4. Update Unity on the full table state
  broadcastToTable(table.tableId, {
    type: "table:full:update",
    tableId: table.tableId,
    gameInProgress: table.gameInProgress,
    players: table.players.map(p => ({
      seatId: p.seatId,
      username: p.username,
      balance: p.balance,
      isAi: p.isAi,
      isDealer: p.isDealer
    }))
  });

  // 5. Final Dealer Assignment Sync
  broadcastToTable(table.tableId, {
    type: "game:dealer:assigned",
    dealer: { 
      username: dealer.username, 
      seatId: dealer.seatId,
      isWarning: table.isWarningActive,
      warningRound: table.dealerWarningRounds,
      bankerPot: table.bankerPot,
      roundsPlayed: table.dealerRoundsPlayed 
    }
  });
}

function finalizeBankerSession(table) {
    const dealer = table.players.find(p => p.username === table.currentDealerName);
    if (dealer && table.bankerPot > 0) {
        dealer.balance += table.bankerPot; // Give remaining pot back to player
    }
    table.bankerPot = 0;
    table.currentDealerName = null;
    table.isWarningActive = false;
    table.dealerWarningRounds = 0;
    rotateDealer(table);
}

function rotateDealer(table) {
  const activePlayers = table.players.filter(p => !p.waiting);
  if (!activePlayers.length) return;

  if (typeof table.rtpStats.dealerIndex !== "number") {
    table.rtpStats.dealerIndex = 0;
  } else {
    table.rtpStats.dealerIndex = (table.rtpStats.dealerIndex + 1) % activePlayers.length;
  }
  console.log(`ðŸ”„ DEALER ROTATED â†’ index ${table.rtpStats.dealerIndex}`);
}

function startGameForTable(table) {
  if (!table || table.gameInProgress || table.countdownInterval) return;
  
  table.roundInProgress = true; 
  table.gameInProgress = true;
  
  // 1. Check who the dealer IS before we run assignment logic
  const oldDealerName = table.currentDealerName;

  // 2. Run the assignment (this updates table.currentDealerName)
  assignDealerForRound(table);

  const newDealer = table.players.find(p => p.username === table.currentDealerName);
  
  // 3. Determine delay
  let startDelay = 0;

  // If the dealer name changed, or if this is the very first dealer of the session
  if (oldDealerName !== table.currentDealerName) {
    startDelay = 3000; // 3 seconds for the "New Dealer" drama
    broadcastToTable(table.tableId, { 
        type: "game:dealer:changed", 
        username: newDealer.username, 
        seatId: newDealer.seatId 
    });
  }

  // 4. Wrap the countdown in the delay
  setTimeout(() => {
    table.countdown = 3;
    broadcastToTable(table.tableId, { type: "game:countdown", seconds: table.countdown });

    table.countdownInterval = setInterval(() => {
      table.countdown--;
      if (table.countdown > 0) {
        broadcastToTable(table.tableId, { type: "game:countdown", seconds: table.countdown });
      } else {
        clearInterval(table.countdownInterval);
        table.countdownInterval = null;
        broadcastToTable(table.tableId, { type: "game:countdown", seconds: 0 });
        startBettingPhase(table);
      }
    }, 1000);
  }, startDelay); 
}

function generateAIBet(table, player) {
  const minBet = table.minBet || table.defaultBet;
  const maxBet = table.maxBet || table.defaultBet * 10;
  const steps = Math.floor((maxBet - minBet) / 100) + 1;
  const randomStep = Math.floor(Math.random() * steps);
  let bet = minBet + randomStep * 100;
  return Math.min(bet, player.balance);
}

function finializeBets(table) {
  table.players.forEach(p => {
    if (p.isDealer) return;
    if (!p.currentBet || p.currentBet <= 0) {
      p.currentBet = p.isAi ? generateAIBet(table, p) : table.defaultBet;
    }
  });
}

function startBettingPhase(table) {
  table.betTime = 5;
  table.players.forEach(p => { p.currentBet = 0; });
  
  broadcastToTable(table.tableId, { type: "game:bet:start", seconds: table.betTime });

  table.players.forEach(p => {
    if (p.isAi && !p.isDealer) p.currentBet = generateAIBet(table, p);
  });

  broadcastToTable(table.tableId, {
    type: "table:bet:update",
    players: table.players.map(p => ({ username: p.username, betAmount: p.currentBet })),
    total: table.players.reduce((s, p) => s + (p.currentBet || 0), 0)
  });

  table.betInterval = setInterval(() => {
    table.betTime--;
    broadcastToTable(table.tableId, { type: "game:bet:timer", seconds: table.betTime });

    if (table.betTime <= 0) {
      clearInterval(table.betInterval);
      table.betInterval = null;
      finializeBets(table);

      broadcastToTable(table.tableId, {
        type: "table:bet:final",
        players: table.players.map(p => ({ username: p.username, betAmount: p.currentBet })),
        total: table.players.reduce((s, p) => s + (p.currentBet || 0), 0)
      });

      broadcastToTable(table.tableId, { type: "game:bet:end" });

      setTimeout(() => {
        // âœ… CRITICAL FIX: Reset roundInProgress so Unity hides the Countdown UI
        table.roundInProgress = false; 

        if (startGameFn) startGameFn(null, { tableId: table.tableId });
        
        broadcastToTable(table.tableId, { type: "game:deal:start", roundId: table.roundId });
        
        // Removed automatic rotateDealer(table) from here; it is now handled by Banker Session logic
      }, 1000);
    }
  }, 1000);
}

module.exports = { autoStart, startGameForTable, startBettingPhase, registerStartGame };