// ===== gameFlow.js =====
const { broadcastToTable } = require("../ws/sender");
const { tables } = require("../state/tables");
let startGameFn = null;

function registerStartGame(fn) {
  startGameFn = fn;
}

function autoStart(table) {
  console.log("ðŸ§ª autoStart()", {
    roundInProgress: table.roundInProgress,
    countdownInterval: !!table.countdownInterval,
    betInterval: !!table.betInterval,
    ready: table.players.map(p => p.ready)
  });

  if (!table || table.players.length === 0) return;
  if (table.roundInProgress || table.betInterval) return;

  const realPlayers = table.players.filter(p => !p.isAi);
  if (realPlayers.length < 1) return;
  if (table.players.length < 3) return; 
  if (!realPlayers.every(p => p.ready)) return;

  console.log(`ðŸ”¥ TABLE READY â†’ STARTING SHAN GAME | table=${table.tableId}`);
  startGameForTable(table);
}

function assignDealerForRound(table) {
  if (!table.rtpStats) return;

  const activePlayers = table.players.filter(p => !p.waiting);
  if (!activePlayers.length) return;

  const minBet = table.minBet || table.defaultBet;
  const buyInAmount = minBet * 10; // 10X Rule

  // 1. Check if current dealer's time is up (Warning finished)
  if (table.isWarningActive && table.dealerWarningRounds >= 3) {
      console.log(`ðŸ›‘ [BANKER SYSTEM] ${table.currentDealerName} finished 3-round warning. Rotating...`);
      finalizeBankerSession(table); 
  }

  // 2. If Banker Pot is empty or zero, we must find/rotate to a new Dealer
  if (!table.bankerPot || table.bankerPot <= 0) {
      if (table.currentDealerName) {
          console.log(`ðŸ›‘ [BANKER SYSTEM] Pot is empty (${table.bankerPot}). Rotating to next player...`);
          finalizeBankerSession(table);
      }

      let startIndex = table.rtpStats.dealerIndex || 0;
      let dealerFound = false;

      for (let i = 0; i < activePlayers.length; i++) {
        const index = (startIndex + i) % activePlayers.length;
        const candidate = activePlayers[index];

        if (candidate.balance >= buyInAmount) {
          // ============================================================
          // ðŸ’° THE DEDUCTION (10X)
          // ============================================================
          candidate.balance -= buyInAmount;
          table.bankerPot = buyInAmount;
          table.dealerStartPot = buyInAmount; // For 3X warning check
          
          table.currentDealerName = candidate.username;
          table.rtpStats.dealerIndex = index;
          table.isWarningActive = false;
          table.dealerWarningRounds = 0;
          dealerFound = true;

          console.log(`ðŸ’° [DEDUCTION] Deducted ${buyInAmount} from ${candidate.username}. New Balance: ${candidate.balance}`);
          console.log(`ðŸ¦ [BANKER POT] Pot initialized with ${table.bankerPot}`);
          break;
        } else {
            console.log(`âš ï¸ [SKIP] ${candidate.username} has insufficient balance for Dealer (Needs ${buyInAmount})`);
        }
      }

      if (!dealerFound) {
        console.log("âŒ [CRITICAL] NO VALID DEALER FOUND AT TABLE (Everyone is too poor)");
        return;
      }
  }

  // Authoritative State Sync
  table.players.forEach(p => p.isDealer = (p.username === table.currentDealerName));
  const dealer = table.players.find(p => p.isDealer);

  // 3. Check for Triple Profit Warning (Based on Pot)
  if (!table.isWarningActive && table.bankerPot >= (table.dealerStartPot * 3)) {
      table.isWarningActive = true;
      console.log(`âš ï¸ [á€á€™á€ºá€á€­á€”á€º] WARNING TRIGGERED! Pot (${table.bankerPot}) is 3x Start (${table.dealerStartPot})`);
      broadcastToTable(table.tableId, { type: "game:dealer:warning", dealer: dealer.username });
  }

  if (table.isWarningActive) {
      table.dealerWarningRounds++;
      console.log(`â³ [WARNING STATUS] Round ${table.dealerWarningRounds}/3 for ${dealer.username}`);
  }

  console.log(`ðŸƒ [DEALER ASSIGNED] ${dealer.username} | Pot: ${table.bankerPot}`);

  broadcastToTable(table.tableId, {
    type: "game:dealer:assigned",
    dealer: { 
      username: dealer.username, 
      seatId: dealer.seatId,
      isWarning: table.isWarningActive,
      bankerPot: table.bankerPot
    }
  });
}

function finalizeBankerSession(table) {
    const dealer = table.players.find(p => p.username === table.currentDealerName);
    if (dealer && table.bankerPot > 0) {
        console.log(`ðŸ’µ [SETTLEMENT] Returning remaining pot ${table.bankerPot} to ${dealer.username}`);
        dealer.balance += table.bankerPot;
    }
    table.bankerPot = 0;
    table.currentDealerName = null;
    table.isWarningActive = false;
    table.dealerWarningRounds = 0;
    rotateDealer(table); 
}

function rotateDealer(table) {
  const activePlayers = table.players.filter(p => !p.waiting);
  if (!activePlayers.length) return;

  if (typeof table.rtpStats.dealerIndex !== "number") {
    table.rtpStats.dealerIndex = 0;
  } else {
    table.rtpStats.dealerIndex = (table.rtpStats.dealerIndex + 1) % activePlayers.length;
  }
  console.log(`ðŸ”„ [ROTATION] Moved Dealer Index to: ${table.rtpStats.dealerIndex}`);
}

function startGameForTable(table) {
  if (!table || table.gameInProgress || table.countdownInterval) return;
  
  table.roundInProgress = true; 
  table.gameInProgress = true;
  
  // This is where the magic happens
  assignDealerForRound(table);
  
  table.countdown = 3;
  broadcastToTable(table.tableId, { type: "game:countdown", seconds: table.countdown });

  table.countdownInterval = setInterval(() => {
    table.countdown--;
    if (table.countdown > 0) {
      broadcastToTable(table.tableId, { type: "game:countdown", seconds: table.countdown });
    } else {
      clearInterval(table.countdownInterval);
      table.countdownInterval = null;
      
      broadcastToTable(table.tableId, { type: "game:countdown", seconds: 0 });
      console.log(`[COUNTDOWN FINISHED] table=${table.tableId}`);
      startBettingPhase(table);
    }
  }, 1000);
}

function generateAIBet(table, player) {
  const minBet = table.minBet || table.defaultBet;
  const maxBet = table.maxBet || table.defaultBet * 10;
  const steps = Math.floor((maxBet - minBet) / 100) + 1;
  const randomStep = Math.floor(Math.random() * steps);
  let bet = minBet + randomStep * 100;
  return Math.min(bet, player.balance);
}

function finializeBets(table) {
  table.players.forEach(p => {
    if (p.isDealer) return;
    if (!p.currentBet || p.currentBet <= 0) {
      p.currentBet = p.isAi ? generateAIBet(table, p) : table.defaultBet;
    }
  });
}

function startBettingPhase(table) {
  table.betTime = 5;
  table.players.forEach(p => { p.currentBet = 0; });
  
  broadcastToTable(table.tableId, { type: "game:bet:start", seconds: table.betTime });

  table.players.forEach(p => {
    if (p.isAi && !p.isDealer) p.currentBet = generateAIBet(table, p);
  });

  broadcastToTable(table.tableId, {
    type: "table:bet:update",
    players: table.players.map(p => ({ username: p.username, betAmount: p.currentBet })),
    total: table.players.reduce((s, p) => s + (p.currentBet || 0), 0)
  });

  table.betInterval = setInterval(() => {
    table.betTime--;
    broadcastToTable(table.tableId, { type: "game:bet:timer", seconds: table.betTime });

    if (table.betTime <= 0) {
      clearInterval(table.betInterval);
      table.betInterval = null;
      finializeBets(table);

      broadcastToTable(table.tableId, {
        type: "table:bet:final",
        players: table.players.map(p => ({ username: p.username, betAmount: p.currentBet })),
        total: table.players.reduce((s, p) => s + (p.currentBet || 0), 0)
      });

      broadcastToTable(table.tableId, { type: "game:bet:end" });

      setTimeout(() => {
        table.roundInProgress = false; 

        if (startGameFn) startGameFn(null, { tableId: table.tableId });
        
        broadcastToTable(table.tableId, { type: "game:deal:start", roundId: table.roundId });
      }, 1000);
    }
  }, 1000);
}

module.exports = { autoStart, startGameForTable, startBettingPhase, registerStartGame };