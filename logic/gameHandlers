
// ===== gameHandler.js =====
const { tables } = require("../state/tables");
const { wsSend, broadcastToTable } = require("../ws/sender");
const { resetPlayersForNextRound, resetTableState } = require("./roundReset");
const { hardResetTable } = require("./roundReset");
const gameFlow = require("./gameFlow");
//const { payoutWinners } = require("./payout");
const gameHelpers = require("./gameHelpers");
const dealerPhase = require("./dealerPhase");
const watchPhase = require("./watchPhase");
const drawPhase = require("./drawPhase");
const resultPhase = require("./resultPhase");

function serializeTablePlayers(table) {
  return table.players.map(p => ({
    seatId: p.seatId,
    username: p.username,
    balance: p.balance,
    isAi: p.isAi,
    ready: p.ready,
    waiting: p.waiting
  }));
}

function clearDealAckTimer(table) {
  if (!table) return;
  if (table.dealAckTimer) {
    clearTimeout(table.dealAckTimer);
    table.dealAckTimer = null;
  }
  table.dealAckDeadlineAt = null;
}

function finalizeDeferredLeaves(table) {
  const deferredPlayers = table.players.filter(p => p.leaveAfterRound);
  if (deferredPlayers.length === 0) return 0;

  deferredPlayers.forEach(p => {
    if (p.ws) {
      p.ws.tableId = null;
      p.ws.username = null;
    }
    p.ws = null;
    console.log(
      `ðŸšª Finalized deferred leave for ${p.username} (${p.leaveReason || "manual"}) on ${table.tableId}`
    );
  });

  table.players = table.players.filter(p => !p.leaveAfterRound);
  console.log(`[LEAVE] finalized deferred count=${deferredPlayers.length} table=${table.tableId}`);
  return deferredPlayers.length;
}


function playerReady(ws, data) {
    const table = tables[data.tableId];
    if (!table) return;
    const player = table.players.find(p => p.username === data.username && !p.isAi);
    if (!player) return;
  
    player.ws = ws; // Keep this for server logic
  
    if (table.roundInProgress) {
      // This part is already clean in your code
      wsSend(ws, {
        type: "table:full:update",
        tableId: table.tableId,
        gameInProgress: table.gameInProgress,
        joinLocked: !!table.joinLockedForRound,
        players: table.players.map(p => ({
          seatId: p.seatId,
          username: p.username,
          balance: p.balance,
          isAi: p.isAi,
          ready: p.ready,
          waiting: p.waiting,
          currentBet: p.currentBet || 0,
          cards: p.cards || []
        }))
      });
      return;
    }
  
    if (player.ready) return;
    player.ready = true;
  
    // ðŸ”¥ FIX: Clean the broadcast here so Unity doesn't crash
    broadcastToTable(table.tableId, {
      type: "table:full:update",
      tableId: table.tableId,
      gameInProgress: table.gameInProgress,
      joinLocked: !!table.joinLockedForRound,
      players: table.players.map(p => ({
          seatId: p.seatId,
          username: p.username,
          balance: p.balance,
          isAi: p.isAi,
          ready: p.ready,
          waiting: p.waiting
      }))
    });
  
    const preRoundPlayers = table.players.filter(p => !p.waiting && !table.roundInProgress);
    if (preRoundPlayers.every(p => p.ready)) {
      table.autoStartCalled = true;
      gameFlow.autoStart(table);
    }
  }

function handlePlayerBet(ws, data) {
  const table = tables[data.tableId];
  if (!table) return;
  const player = table.players.find(p => p.username === data.username);
  if (!player || player.isDealer) return;
  if (player.leaveAfterRound) {
    wsSend(ws, { type: "game:bet:res", success: false, error: "leave pending" });
    return;
  }

  player.currentBet = Number(data.betAmount) || 0;
  const total = table.players.reduce((sum, p) => sum + (p.currentBet || 0), 0);
  broadcastToTable(table.tableId, {
      type: "table:bet:update",
      players: table.players.map(p => ({ username: p.username, betAmount: p.currentBet })),
      total
  });
  wsSend(ws, { type: "game:bet:res", success: true });
}

function handleGameResult(ws, data)
{
  const body = data.data || data;
  const table = tables[body.tableId];
  if (!table) return;
  const player = table.players.find(p => p.seatId == body.seatId);
  if (player) player.balance += Number(body.updatePoint || 0);

  // âŒ THIS LINE IS THE KILLER:
  // broadcastToTable(table.tableId, { type: "table:update", tableId: table.tableId, players: table.players });
  
  // âœ… CHANGE TO THIS (Clean the players list):
  broadcastToTable(table.tableId, {
      type: "table:update",
      tableId: table.tableId,
      players: table.players.map(p => ({
          username: p.username,
          balance: p.balance,
          seatId: p.seatId,
          isAi: p.isAi,
          ready: p.ready
      }))
  });

  wsSend(ws, { type: "game:result:res", success: true });
}

function handlePlayerDrawRequest(ws, data)
{
  const { tableId, username, action } = data; // action: "draw" or "stop"
  const table = tables[tableId];
  if (!table || !table.watchTimer) return;

  const player = table.players.find(p => p.username === username);
  if (!player) return;
  if (player.leaveAfterRound) {
    console.log(`â›” Ignored draw action from leaving player ${username}`);
    return;
  }
    // ðŸ”¥ ADD THIS LINE
  player.ws = ws;
  player.drawAction = action;
  console.log(`ðŸ“© [ACTION] ${username} wants to ${action}`);
}

function scheduleNextRound(tableId) {
    const table = tables[tableId];
    // ðŸ”¥ STOP! If we are already waiting to restart, don't run this again.
    if (!table || table.waitingForNextRound) return;
    
    table.waitingForNextRound = true;
    console.log(`â³ Round over. Cleaning table ${tableId}...`);

    setTimeout(() => {
        // 1. FORCE CLEAR all timers so they don't overlap
        [table.countdownInterval, table.betInterval, table.watchTimer, table.findWinnerTimer, table.payoutTimer, table.dealAckTimer].forEach(t => {
            if (t) clearInterval(t);
            if (t) clearTimeout(t);
        });
        table.countdownInterval = table.betInterval = table.watchTimer = table.findWinnerTimer = table.payoutTimer = table.dealAckTimer = null;
        table.dealAckDeadlineAt = null;

        // 2. WIPE the table and players (Promotes spectators to players)
        resetTableState(table);
        const deferredRemoved = finalizeDeferredLeaves(table);
        if (deferredRemoved > 0) {
            broadcastToTable(tableId, {
                type: "table:update",
                tableId,
                players: serializeTablePlayers(table)
            });
        }

        const realPlayersLeft = table.players.filter(p => !p.isAi).length;
        if (realPlayersLeft === 0) {
            console.log(`ðŸ§¹ No real players left on ${tableId} after deferred leaves`);
            hardResetTable(table);
            broadcastToTable(tableId, { type: "table:reset", tableId });
            return;
        }

        resetPlayersForNextRound(table);

        // 3. RESET all state flags to "Fresh"
        table.gameInProgress = false;
        table.roundInProgress = false;
        table.watchTimerStarted = false;
        table.dealAckReceived = false;
        table.autoStartCalled = false;
        
        // 4. FORCE READY: This ensures the loop doesn't wait for human clicks
        table.players.forEach(p => p.ready = true);

        // 5. UNLOCK the scheduler for the next round
        table.waitingForNextRound = false;

        // 6. ðŸš€ THE JUMPSTART
        if (table.players.length > 0) {
            console.log("â™»ï¸ Auto-Restarting next round now...");
            gameFlow.autoStart(table);
        }
    }, 4000); // 4 seconds: Perfect time for Unity to finish payout animations
}

const mapCardsToStrings = (cards) => {
    if (!cards) return [];
    const suitMap = { 4: "S", 3: "H", 2: "D", 1: "C" };
    return cards.map(c => typeof c === 'string' ? c : `${c.rank}${suitMap[c.suit]}`);
};

function advanceAfterDealAck(table, roundId, source) {
    if (!table || roundId !== table.roundId) return false;
    if (table.dealAckReceived) {
        console.log(`â›” DEAL ACK duplicate ignored | table=${table.tableId} round=${roundId} source=${source}`);
        return false;
    }

    table.dealAckReceived = true;
    clearDealAckTimer(table);
    console.log(`âœ… DEAL ACK accepted | table=${table.tableId} round=${roundId} source=${source}`);

    const dealer = table.players.find(p => p.isDealer);
    if (!dealer || !Array.isArray(dealer.cards) || dealer.cards.length < 2) {
        console.warn(`âš ï¸ DEAL ACK flow aborted: missing dealer/cards | table=${table.tableId} round=${roundId}`);
        return false;
    }
    const dealerRes = gameHelpers.calculateShanResult(dealer.cards);

    if (dealerRes.points >= 8) {
        broadcastToTable(table.tableId, {
            type: "game:dealer:natural",
            points: dealerRes.points
        });

        broadcastToTable(table.tableId, { type: "ui:cardview:show", roundId });

        setTimeout(() => {
            broadcastToTable(table.tableId, {
                type: "table:cards:reveal",
                players: table.players.map(p => {
                    if (!Array.isArray(p.cards) || p.cards.length < 2) {
                        return {
                            username: p.username,
                            seatId: p.seatId,
                            cards: [],
                            points: 0,
                            multiplier: 1,
                            isShan: false
                        };
                    }
                    const res = gameHelpers.calculateShanResult(p.cards);

                    return {
                        username: p.username,
                        seatId: p.seatId,
                        cards: mapCardsToStrings(p.cards),
                        points: res.points,
                        multiplier: res.multiplier,
                        isShan: res.isDo
                    };
                })
            });

            broadcastToTable(table.tableId, {
                type: "ui:cardview:hide",
                roundId
            });

            setTimeout(() => {
                resultPhase.startFindWinnerPhase(
                    table.tableId,
                    roundId,
                    scheduleNextRound
                );
            }, 2000);
        }, 1500);

        return true;
    }

    setTimeout(() => {
        broadcastToTable(table.tableId, {
            type: "ui:cardview:show",
            roundId
        });

        watchPhase.startWatchTwoCardPhase(
            table.tableId,
            roundId,
            () => {
                drawPhase.processFinalDraws(
                    table.tableId,
                    roundId,
                    (innerTableId, innerRoundId) => {
                        resultPhase.startFindWinnerPhase(
                            innerTableId,
                            innerRoundId,
                            scheduleNextRound
                        );
                    }
                );
            }
        );
    }, 500);

    return true;
}

function recoverDealAckTimeout(tableId, roundId) {
    const table = tables[tableId];
    if (!table) return;
    if (roundId !== table.roundId) {
        console.log(`â›” DEAL ACK timeout ignored (round changed) | table=${tableId} timerRound=${roundId} liveRound=${table.roundId}`);
        return;
    }
    if (table.dealAckReceived) {
        console.log(`â›” DEAL ACK timeout ignored (already acked) | table=${tableId} round=${roundId}`);
        return;
    }

    console.warn(`ðŸ›Ÿ DEAL ACK timeout recovery | table=${tableId} round=${roundId}`);
    broadcastToTable(tableId, { type: "game:deal:recover", tableId, roundId });
    advanceAfterDealAck(table, roundId, "timeout-recovery");
}

function handleDealFinished(ws, data) {
    const { tableId, roundId } = data;
    const table = tables[tableId];
    if (!table || roundId !== table.roundId) return;
    if (table.dealAckReceived) {
        console.log(`â›” Late/duplicate client deal ACK ignored | table=${tableId} round=${roundId}`);
        return;
    }
    advanceAfterDealAck(table, roundId, "client-ack");
}

module.exports = {
    playerReady,
    handleGameResult,
    scheduleNextRound,
    handlePlayerBet,
    handleDealFinished,
    handlePlayerDrawRequest,
    recoverDealAckTimeout
};
