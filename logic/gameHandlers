
// ===== gameHandler.js =====
const { tables } = require("../state/tables");
const { wsSend, broadcastToTable } = require("../ws/sender");
const { resetPlayersForNextRound, resetTableState } = require("./roundReset");
const gameFlow = require("./gameFlow");
const { payoutWinners } = require("./payout");
const gameHelpers = require("./gameHelpers");

function playerReady(ws, data) {
    const table = tables[data.tableId];
    if (!table) return;
    const player = table.players.find(p => p.username === data.username && !p.isAi);
    if (!player) return;
  
    player.ws = ws; // Keep this for server logic
  
    if (table.roundInProgress) {
      // This part is already clean in your code
      wsSend(ws, {
        type: "table:full:update",
        tableId: table.tableId,
        gameInProgress: table.gameInProgress,
        players: table.players.map(p => ({
          seatId: p.seatId,
          username: p.username,
          balance: p.balance,
          isAi: p.isAi,
          ready: p.ready,
          waiting: p.waiting,
          currentBet: p.currentBet || 0,
          cards: p.cards || []
        }))
      });
      return;
    }
  
    if (player.ready) return;
    player.ready = true;
  
    // ðŸ”¥ FIX: Clean the broadcast here so Unity doesn't crash
    broadcastToTable(table.tableId, { 
      type: "table:full:update", 
      tableId: table.tableId, 
      gameInProgress: table.gameInProgress, 
      players: table.players.map(p => ({
          seatId: p.seatId,
          username: p.username,
          balance: p.balance,
          isAi: p.isAi,
          ready: p.ready,
          waiting: p.waiting
      }))
    });
  
    const preRoundPlayers = table.players.filter(p => !p.waiting && !table.roundInProgress);
    if (preRoundPlayers.every(p => p.ready)) {
      table.autoStartCalled = true;
      gameFlow.autoStart(table);
    }
  }

function handlePlayerBet(ws, data) {
  const table = tables[data.tableId];
  if (!table) return;
  const player = table.players.find(p => p.username === data.username);
  if (!player || player.isDealer) return;

  player.currentBet = Number(data.betAmount) || 0;
  const total = table.players.reduce((sum, p) => sum + (p.currentBet || 0), 0);
  broadcastToTable(table.tableId, {
      type: "table:bet:update",
      players: table.players.map(p => ({ username: p.username, betAmount: p.currentBet })),
      total
  });
  wsSend(ws, { type: "game:bet:res", success: true });
}

function handleGameResult(ws, data) 
{
  const body = data.data || data;
  const table = tables[body.tableId];
  if (!table) return;
  const player = table.players.find(p => p.seatId == body.seatId);
  if (player) player.balance += Number(body.updatePoint || 0);

  // âŒ THIS LINE IS THE KILLER:
  // broadcastToTable(table.tableId, { type: "table:update", tableId: table.tableId, players: table.players });
  
  // âœ… CHANGE TO THIS (Clean the players list):
  broadcastToTable(table.tableId, { 
      type: "table:update", 
      tableId: table.tableId, 
      players: table.players.map(p => ({
          username: p.username,
          balance: p.balance,
          seatId: p.seatId,
          isAi: p.isAi,
          ready: p.ready
      }))
  });

  wsSend(ws, { type: "game:result:res", success: true });
}

function handlePlayerDrawRequest(ws, data) 
{
  const { tableId, username, action } = data; // action: "draw" or "stop"
  const table = tables[tableId];
  if (!table || !table.watchTimer) return;

  const player = table.players.find(p => p.username === username);
  if (!player) return;
    // ðŸ”¥ ADD THIS LINE
  player.ws = ws;
  player.drawAction = action; 
  console.log(`ðŸ“© [ACTION] ${username} wants to ${action}`);
}

function scheduleNextRound(tableId) {
    const table = tables[tableId];
    if (!table || table.waitingForNextRound) return;
    table.waitingForNextRound = true;
    setTimeout(() => {
      [table.countdownInterval, table.betInterval, table.watchTimer, table.findWinnerTimer, table.payoutTimer].forEach(t => t && clearInterval(t));
      table.countdownInterval = table.betInterval = table.watchTimer = table.findWinnerTimer = table.payoutTimer = null;
      resetTableState(table);
      resetPlayersForNextRound(table);
      table.gameInProgress = table.roundInProgress = table.watchTimerStarted = table.dealAckReceived = table.waitingForNextRound = table.autoStartCalled = false;
      table.players.forEach(p => p.ready = true);
      if (!table.countdownInterval && !table.betInterval && !table.roundInProgress) {
        gameFlow.autoStart(table);
    }
    
    }, 3000);
}
    
function handleDealFinished(ws, data) {
    const { tableId, roundId } = data;
    const table = tables[tableId];
    if (!table || roundId !== table.roundId || table.dealAckReceived) return;
    table.dealAckReceived = true;

    const dealer = table.players.find(p => p.isDealer);
    const dealerRes = gameHelpers.calculateShanResult(dealer.cards);

   // If dealer has 8 or 9, we still show cards but skip the drawing phase
   if (dealerRes.points >= 8) {
    broadcastToTable(tableId, { type: "game:dealer:natural", points: dealerRes.points });
    
    // 1. Let players see their own cards first
    broadcastToTable(tableId, { type: "ui:cardview:show", roundId });

    setTimeout(() => {
        // 2. ðŸ”¥ CATCHALL: Reveal everyone's cards to everyone
        broadcastToTable(tableId, { 
            type: "table:cards:reveal", 
            players: table.players.map(p => ({
                username: p.username,
                cards: p.cards // Send the full card data
            }))
        });

        // 3. Hide the private "peek" UI and move to winners
        broadcastToTable(tableId, { type: "ui:cardview:hide", roundId });
        
        // Give them an extra 2 seconds to see the whole table's cards 
        // before the payout logic kicks in
        setTimeout(() => {
            startFindWinnerPhase(tableId, roundId);
        }, 2000);

    }, 5000); // Your 5s viewing time
    
    return; 
}
    // --- NORMAL FLOW (Dealer < 8) ---
    setTimeout(() => {
        broadcastToTable(tableId, { type: "ui:cardview:show", roundId });
        let remainingWatch = 7;
        broadcastToTable(tableId, { type: "game:watch2card:start", seconds: remainingWatch, roundId });

        table.watchTimer = setInterval(() => {
            remainingWatch--;
            if (remainingWatch <= 0) {
                clearInterval(table.watchTimer);
        
                broadcastToTable(tableId, {
                    type: "game:watch2card:end",
                    roundId
                });
        
                broadcastToTable(tableId, {
                    type: "ui:cardview:hide",
                    roundId
                });
        
                processFinalDraws(tableId, roundId);
            } else {
                broadcastToTable(tableId, {
                    type: "game:watch2card:tick",
                    seconds: remainingWatch,
                    roundId
                });
            }
        }, 1000);
        
    }, 500); 
}

function processFinalDraws(tableId, roundId) {
    const table = tables[tableId];
    let anyoneDrew = false;

    console.log(`--- [DRAW PHASE START] Table: ${tableId} ---`);

    // ===============================
    // ðŸ‘‘ DEALER AUTO DRAW (ðŸ”¥ FIX)
    // ===============================
    const dealer = table.players.find(p => p.isDealer);
    if (dealer) {
        const dealerRes = gameHelpers.calculateShanResult(dealer.cards);

        console.log(`ðŸ‘‘ [DEALER CHECK] Points: ${dealerRes.points} | Cards: ${dealer.cards.length}`);

        if (
            dealer.cards.length === 2 &&
            dealerRes.points < 4 &&
            !dealer.hasDrawn
        ) {
            const card = table.deck[table.deckIndex++];
            dealer.cards.push(card);
            dealer.hasDrawn = true;
            anyoneDrew = true;

            const cardName = `${card.rank}${{4:"S",3:"H",2:"D",1:"C"}[card.suit]}`;
            console.log(`ðŸ‘‘âœ… [DEALER AUTO DRAW] Card: ${cardName}`);

            broadcastToTable(tableId, {
                type: "game:dealer:auto_draw",
                card: cardName,
                roundId
            });
        }
    }

    // ===============================
    // ðŸ‘¤ PLAYER DRAW LOGIC (UNCHANGED)
    // ===============================
    table.players.forEach(p => {
        if (p.waiting || p.isDealer) return;

        const res = gameHelpers.calculateShanResult(p.cards);
        if (res.points >= 8) return;

        if (p.isAi && res.points < 4) p.drawAction = "draw";

        if (p.drawAction === "draw" || (!p.drawAction && res.points < 4)) {
            if (p.cards.length === 2) {
                const card = table.deck[table.deckIndex++];
                p.cards.push(card);
                anyoneDrew = true;

                const cardName = `${card.rank}${{4:"S",3:"H",2:"D",1:"C"}[card.suit]}`;
                console.log(`âœ… [DRAW] Player: ${p.username} | Card: ${cardName}`);

                broadcastToTable(tableId, {
                    type: "game:player:draw",
                    username: p.username,
                    card: cardName
                });
            }
        } else {
            console.log(`âŒ [STAY] Player: ${p.username} | Points: ${res.points}`);
        }
    });

    // ===============================
    // â­ NEXT PHASE
    // ===============================
    if (anyoneDrew) {
        startSecondWatchPhase(tableId, roundId);
    } else {
        startFindWinnerPhase(tableId, roundId);
    }
}


function startSecondWatchPhase(tableId, roundId) {
    const table = tables[tableId];

    setTimeout(() => {
        console.log(`--- [SECOND WATCH] Checking ${table.players.length} players for 3rd card UI ---`);

        table.players.forEach(p => {
            const cardCount = p.cards ? p.cards.length : 0;
            
            if (cardCount === 3) {
                // Determine if player is AI or Human
                if (p.isAi) {
                    console.log(`ðŸ¤– [SKIP] ${p.username} is AI (No UI needed)`);
                    return;
                }

                // Check for the socket
                const socket = p.ws || p.socket; 
                if (socket) {
                    console.log(`ðŸ“± [UI_SHOW] SUCCESS: Sending CardView to human: ${p.username}`);
                    wsSend(socket, { type: "ui:cardview:show", roundId });
                } else {
                    console.log(`âš ï¸ [ERROR] ${p.username} has 3 cards but NO SOCKET (ws) found in player object!`);
                }
            } else {
                console.log(`â„¹ï¸ [SKIP] ${p.username} has ${cardCount} cards (No UI needed)`);
            }
        });

        let secondWatchTime = 7;
        broadcastToTable(tableId, { type: "game:watch3card:start", seconds: secondWatchTime, roundId });

        const secondTimer = setInterval(() => {
            secondWatchTime--;
        
            if (secondWatchTime <= 0) {
                clearInterval(secondTimer);
        
                broadcastToTable(tableId, {
                    type: "game:watch3card:end",
                    roundId
                });
        
                broadcastToTable(tableId, {
                    type: "ui:cardview:hide",
                    roundId
                });
        
                startDealerActionPhase(tableId, roundId);
            } else {
                broadcastToTable(tableId, {
                    type: "game:watch3card:tick",
                    seconds: secondWatchTime,
                    roundId
                });
            }
        }, 1000);
        
    }, 1500); 
}

function handleDealerDecision(ws, data) {
    const { tableId, action, seatId } = data;
    const table = tables[tableId];
    if (!table) return;

    const dealer = table.players.find(p => p.isDealer);
    if (!dealer) return;

    // Stop dealer timer if running
    if (table.dealerActionTimer) {
        clearInterval(table.dealerActionTimer);
        table.dealerActionTimer = null;
    }

    console.log(`ðŸ‘‘ [DEALER ACTION RECEIVED] ${action}`);

    // ðŸ”¥ IMPORTANT: DO NOT DRAW HERE
    // Forward everything to ONE execution path
    executeDealerAction(tableId, table.roundId, action,seatId);
}


function startDealerActionPhase(tableId, roundId) {
    const table = tables[tableId];
    const dealer = table.players.find(p => p.isDealer);

    console.log(`ðŸ‘‘ [DEALER ACTION START] Table:${tableId} | Round:${roundId}`);

    const threeCardPlayers = table.players
        .filter(p => p.cards && p.cards.length === 3)
        .sort((a, b) => a.seatId - b.seatId);

    console.log(
        `ðŸŽ¯ [3CARD PLAYERS]`,
        threeCardPlayers.map(p => `${p.username}(seat:${p.seatId})`)
    );

    broadcastToTable(tableId, {
        type: "game:dealer:action:start",
        roundId,
        seconds: 10,
        threeCardPlayers: threeCardPlayers.map(p => ({
            username: p.username,
            seatId: p.seatId
        }))
    });

    // ðŸ¤– AI DEALER AUTO ACTION
    if (dealer.isAi) {
        setTimeout(() => {
            runAIDealerAction(tableId, roundId);
        }, 1500);
        return;
    }

    // ðŸ‘¤ HUMAN DEALER TIMER
    let timeLeft = 10;
    table.dealerActionTimer = setInterval(() => {
        timeLeft--;

        if (timeLeft <= 0) {
            clearInterval(table.dealerActionTimer);
            table.dealerActionTimer = null;

            console.log(`â±ï¸ [DEALER TIMEOUT] AUTO SKIP`);
            executeDealerAction(tableId, roundId, "skip");
        } else {
            broadcastToTable(tableId, {
                type: "game:dealer:action:tick",
                seconds: timeLeft,
                roundId
            });
        }
    }, 1000);
}

function runAIDealerAction(tableId, roundId) {
    const table = tables[tableId];
    const dealer = table.players.find(p => p.isDealer);
    const dealerRes = gameHelpers.calculateShanResult(dealer.cards);

    const threeCardPlayers = table.players.filter(p => p.cards.length === 3);

    let action = "skip";

    if (dealerRes.points < 4 && dealer.cards.length === 2) {
        action = "draw";
    } else if (threeCardPlayers.length > 0) {
        action = "catch3cards";
    } else {
        action = "catchall";
    }

    console.log(`ðŸ¤–ðŸ‘‘ [AI DEALER ACTION] ${action}`);
    executeDealerAction(tableId, roundId, action);
}


function executeDealerAction(tableId, roundId, action,seatId = null) {
    const table = tables[tableId];
    const dealer = table.players.find(p => p.isDealer);
    if (!dealer) return;

    if (dealer.hasDrawn === undefined) dealer.hasDrawn = false;

    if (table.dealerActionTimer) {
        clearInterval(table.dealerActionTimer);
        table.dealerActionTimer = null;
    }

    console.log(`ðŸ‘‘ [DEALER ACTION EXECUTE] ${action}`);

    switch (action) {

        case "catchsingle": {

            if (seatId === null) {
                console.log("âŒ catchsingle failed: no seatId");
                break;
            }
        
            const target = table.players.find(p => p.seatId == seatId);
        
            if (!target) {
                console.log("âŒ catchsingle failed: invalid seatId");
                break;
            }
        
            if (!target.cards || target.cards.length === 0) {
                console.log("âŒ catchsingle failed: no cards");
                break;
            }
        
            console.log(`ðŸ‘‘ðŸŽ¯ [DEALER CATCH SINGLE] Seat:${seatId} | ${target.username}`);
        
            broadcastToTable(tableId, {
                type: "game:dealer:catchsingle",
                player: {
                    username: target.username,
                    seatId: target.seatId,
                    cards: target.cards
                },
                roundId
            });
        
            break;
        }
        case "catch3cards": {
            const players = table.players
                .filter(p => p.cards && p.cards.length === 3)
                .sort((a, b) => a.seatId - b.seatId);

            broadcastToTable(tableId, {
                type: "game:dealer:catch3cards",
                players: players.map(p => ({
                    username: p.username,
                    seatId: p.seatId,
                    cards: p.cards
                })),
                roundId
            });
            break;
        }

        case "catchall": {
            broadcastToTable(tableId, {
                type: "game:dealer:catchall",
                players: table.players.map(p => ({
                    username: p.username,
                    seatId: p.seatId,
                    cards: p.cards
                })),
                roundId
            });
            break;
        }

        case "draw": {
            if (dealer.hasDrawn) {
                console.log(`âŒ [DEALER DRAW BLOCKED] Already drew`);
                break;
            }

            if (dealer.cards.length === 2) {
                dealer.hasDrawn = true; // ðŸ”¥ IMPORTANT FIX

                const card = table.deck[table.deckIndex++];
                dealer.cards.push(card);

                const cardName = `${card.rank}${{4:"S",3:"H",2:"D",1:"C"}[card.suit]}`;
                console.log(`ðŸ‘‘âœ… [DEALER DRAW] Card:${cardName}`);

                broadcastToTable(tableId, {
                    type: "game:dealer:draw",
                    card: cardName,
                    roundId
                });
            }
            break;
        }

        case "skip":
        default:
            console.log(`ðŸ‘‘âŒ [DEALER SKIP]`);
            break;
    }

    setTimeout(() => {
        startFindWinnerPhase(tableId, roundId);
    }, 1500);
}

function startFindWinnerPhase(tableId, roundId) {
    const table = tables[tableId];
    let findWinnerTime = 5;
    broadcastToTable(tableId, { type: "game:findwinner:start", seconds: findWinnerTime, roundId });

    table.findWinnerTimer = setInterval(() => {
        findWinnerTime--;

        if (findWinnerTime <= 0) {
            clearInterval(table.findWinnerTimer);
            const activePlayers = table.players.filter(p => !p.waiting);
            // LOG DEALER FINAL STATE
            const dealer = activePlayers.find(p => p.isDealer);
            if (!dealer) {
                console.error("âŒ Dealer not found at findWinner phase");
                return;
            }
            const dRes = gameHelpers.calculateShanResult(dealer.cards);
            console.log(`DEALER Hand: ${dRes.points} points | Multiplier: x${dRes.payoutMultiplier}`);

            const winnerPlayers = gameHelpers.decideDealerWinners(activePlayers);
            table.currentWinners = winnerPlayers.map(p => p.username || p.name);

            const tableResult = gameHelpers.buildTableResult(table);
            // 3ï¸âƒ£ ðŸ”¥ BROADCAST FULL RESULT (THIS WAS MISSING)
            broadcastToTable(tableId, {
                type: "game:round:result",
                ...tableResult
            });

            // LOG INDIVIDUAL PLAYER RESULTS
            activePlayers.forEach(p => {
                if (p.isDealer) return;
                const res = gameHelpers.calculateShanResult(p.cards);
                const isWinner = table.currentWinners.includes(p.username);
                console.log(`PLAYER ${p.username} ${isWinner ? "WINS" : "LOSES"} with ${res.points} pts (x${res.multiplier || 1})`);
            });
            

            startPayoutPhase(tableId, roundId);
        } else {
            broadcastToTable(tableId, { type: "game:findwinner:tick", seconds: findWinnerTime, roundId });
        }
    }, 1000);
}

function startPayoutPhase(tableId, roundId) {
    const table = tables[tableId];
    let payoutTime = 5;
    const payoutResults = payoutWinners(table,table.players, table.currentWinners);
    
    // LOG DETAILED MONEY FLOW
    payoutResults.forEach(res => {
        const p = table.players.find(player => player.username === res.username);
        if (p && !p.isDealer) {
            const isWin = table.currentWinners.includes(p.username);
            if (isWin) {
                console.log(`ðŸ’µ WIN â†’ ${p.username} | Bet:${p.currentBet} | x${p.multiplier || 1} | Dealer pays:${res.delta}`);
            }
        }
    });

    broadcastToTable(tableId, { type: "game:payout:result", roundId, results: payoutResults });

    table.payoutTimer = setInterval(() => {
        payoutTime--;
        if (payoutTime <= 0) {
            clearInterval(table.payoutTimer);
            // ðŸ”¥ ADD THIS LINE RIGHT HERE! 
            // Without this, ShanPhaseHandler.cs NEVER gets the signal to clean the UI.
            broadcastToTable(tableId, { type: "game:payout:end", roundId: roundId });
            scheduleNextRound(tableId);
        } else {
            broadcastToTable(tableId, { type: "game:payout:tick", seconds: payoutTime, roundId });
        }
    }, 1000);
}

module.exports = { 
    playerReady, 
    handleGameResult, 
    scheduleNextRound, 
    handlePlayerBet, 
    handleDealFinished, 
    handlePlayerDrawRequest 
};