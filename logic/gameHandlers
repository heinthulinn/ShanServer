
// ===== gameHandler.js =====
const { tables } = require("../state/tables");
const { wsSend, broadcastToTable } = require("../ws/sender");
const { resetPlayersForNextRound, resetTableState } = require("./roundReset");
const gameFlow = require("./gameFlow");
//const { payoutWinners } = require("./payout");
const gameHelpers = require("./gameHelpers");
const dealerPhase = require("./dealerPhase");
const watchPhase = require("./watchPhase");
const drawPhase = require("./drawPhase");
const resultPhase = require("./resultPhase");


function playerReady(ws, data) {
    const table = tables[data.tableId];
    if (!table) return;
    const player = table.players.find(p => p.username === data.username && !p.isAi);
    if (!player) return;
  
    player.ws = ws; // Keep this for server logic
  
    if (table.roundInProgress) {
      // This part is already clean in your code
      wsSend(ws, {
        type: "table:full:update",
        tableId: table.tableId,
        gameInProgress: table.gameInProgress,
        players: table.players.map(p => ({
          seatId: p.seatId,
          username: p.username,
          balance: p.balance,
          isAi: p.isAi,
          ready: p.ready,
          waiting: p.waiting,
          currentBet: p.currentBet || 0,
          cards: p.cards || []
        }))
      });
      return;
    }
  
    if (player.ready) return;
    player.ready = true;
  
    // ðŸ”¥ FIX: Clean the broadcast here so Unity doesn't crash
    broadcastToTable(table.tableId, { 
      type: "table:full:update", 
      tableId: table.tableId, 
      gameInProgress: table.gameInProgress, 
      players: table.players.map(p => ({
          seatId: p.seatId,
          username: p.username,
          balance: p.balance,
          isAi: p.isAi,
          ready: p.ready,
          waiting: p.waiting
      }))
    });
  
    const preRoundPlayers = table.players.filter(p => !p.waiting && !table.roundInProgress);
    if (preRoundPlayers.every(p => p.ready)) {
      table.autoStartCalled = true;
      gameFlow.autoStart(table);
    }
  }

function handlePlayerBet(ws, data) {
  const table = tables[data.tableId];
  if (!table) return;
  const player = table.players.find(p => p.username === data.username);
  if (!player || player.isDealer) return;

  player.currentBet = Number(data.betAmount) || 0;
  const total = table.players.reduce((sum, p) => sum + (p.currentBet || 0), 0);
  broadcastToTable(table.tableId, {
      type: "table:bet:update",
      players: table.players.map(p => ({ username: p.username, betAmount: p.currentBet })),
      total
  });
  wsSend(ws, { type: "game:bet:res", success: true });
}

function handleGameResult(ws, data) 
{
  const body = data.data || data;
  const table = tables[body.tableId];
  if (!table) return;
  const player = table.players.find(p => p.seatId == body.seatId);
  if (player) player.balance += Number(body.updatePoint || 0);

  // âŒ THIS LINE IS THE KILLER:
  // broadcastToTable(table.tableId, { type: "table:update", tableId: table.tableId, players: table.players });
  
  // âœ… CHANGE TO THIS (Clean the players list):
  broadcastToTable(table.tableId, { 
      type: "table:update", 
      tableId: table.tableId, 
      players: table.players.map(p => ({
          username: p.username,
          balance: p.balance,
          seatId: p.seatId,
          isAi: p.isAi,
          ready: p.ready
      }))
  });

  wsSend(ws, { type: "game:result:res", success: true });
}

function handlePlayerDrawRequest(ws, data) 
{
  const { tableId, username, action } = data; // action: "draw" or "stop"
  const table = tables[tableId];
  if (!table || !table.watchTimer) return;

  const player = table.players.find(p => p.username === username);
  if (!player) return;
    // ðŸ”¥ ADD THIS LINE
  player.ws = ws;
  player.drawAction = action; 
  console.log(`ðŸ“© [ACTION] ${username} wants to ${action}`);
}

function scheduleNextRound(tableId) {
    const table = tables[tableId];
    if (!table || table.waitingForNextRound) return;
    table.waitingForNextRound = true;
    setTimeout(() => {
      [table.countdownInterval, table.betInterval, table.watchTimer, table.findWinnerTimer, table.payoutTimer].forEach(t => t && clearInterval(t));
      table.countdownInterval = table.betInterval = table.watchTimer = table.findWinnerTimer = table.payoutTimer = null;
      resetTableState(table);
      resetPlayersForNextRound(table);
      table.gameInProgress = table.roundInProgress = table.watchTimerStarted = table.dealAckReceived = table.waitingForNextRound = table.autoStartCalled = false;
      table.players.forEach(p => p.ready = true);
      if (!table.countdownInterval && !table.betInterval && !table.roundInProgress) {
        gameFlow.autoStart(table);
    }
    
    }, 3000);
}

const mapCardsToStrings = (cards) => {
    if (!cards) return [];
    const suitMap = { 4: "S", 3: "H", 2: "D", 1: "C" };
    return cards.map(c => typeof c === 'string' ? c : `${c.rank}${suitMap[c.suit]}`);
};
    
function handleDealFinished(ws, data) {
    const { tableId, roundId } = data;
    const table = tables[tableId];
    if (!table || roundId !== table.roundId || table.dealAckReceived) return;

    table.dealAckReceived = true;

    const dealer = table.players.find(p => p.isDealer);
    const dealerRes = gameHelpers.calculateShanResult(dealer.cards);

    // ===============================
    // ðŸ”¥ DEALER NATURAL (8 or 9)
    // ===============================
    if (dealerRes.points >= 8) {

        broadcastToTable(tableId, { 
            type: "game:dealer:natural", 
            points: dealerRes.points 
        });

        // Show peek UI first
        broadcastToTable(tableId, { type: "ui:cardview:show", roundId});

        setTimeout(() => {

            // Reveal all table cards
            broadcastToTable(tableId, { 
                type: "table:cards:reveal",
                players: table.players.map(p => ({
                    username: p.username,
                    seatId: p.seatId,
                    cards: mapCardsToStrings(p.cards) // <-- THIS WAS THE BUG
                }))
            });

            // Hide peek UI
            broadcastToTable(tableId, { 
                type: "ui:cardview:hide", 
                roundId 
            });

            // Directly go to result phase (NO WATCH, NO DRAW)
            setTimeout(() => {
                resultPhase.startFindWinnerPhase(
                    tableId,
                    roundId,
                    scheduleNextRound
                );
            }, 2000);

        }, 1500);

        return;
    }

    // =====================================
    // ðŸ”µ NORMAL FLOW (Dealer < 8)
    // =====================================
    setTimeout(() => {

        broadcastToTable(tableId, { 
            type: "ui:cardview:show", 
            roundId 
        });

        watchPhase.startWatchTwoCardPhase(
            tableId,
            roundId,
            () => {
                drawPhase.processFinalDraws(
                    tableId,
                    roundId,
                    (tableId, roundId) => {
                        resultPhase.startFindWinnerPhase(
                            tableId,
                            roundId,
                            scheduleNextRound
                        );
                    }
                );
            }
        );

    }, 500);
}

module.exports = { 
    playerReady, 
    handleGameResult, 
    scheduleNextRound, 
    handlePlayerBet, 
    handleDealFinished, 
    handlePlayerDrawRequest 
};