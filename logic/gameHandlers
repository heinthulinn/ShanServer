
// ===== gameHandler.js =====
const { tables } = require("../state/tables");
const { wsSend, broadcastToTable } = require("../ws/sender");
const { resetPlayersForNextRound, resetTableState } = require("./roundReset");
const gameFlow = require("./gameFlow");
const { payoutWinners } = require("./payout");
const gameHelpers = require("./gameHelpers");

function playerReady(ws, data) {
  const table = tables[data.tableId];
  if (!table) return;
  const player = table.players.find(p => p.username === data.username && !p.isAi);
  if (!player) return;

  if (table.roundInProgress) {
    wsSend(ws, {
      type: "table:full:update",
      tableId: table.tableId,
      gameInProgress: table.gameInProgress,
      players: table.players.map(p => ({
        seatId: p.seatId,
        username: p.username,
        balance: p.balance,
        isAi: p.isAi,
        ready: p.ready,
        waiting: p.waiting,
        currentBet: p.currentBet || 0,
        cards: p.cards || []
      }))
    });
    return;
  }

  if (player.ready) return;
  player.ready = true;
  broadcastToTable(table.tableId, { type: "table:full:update", tableId: table.tableId, gameInProgress: table.gameInProgress, players: table.players });

  const preRoundPlayers = table.players.filter(p => !p.waiting && !table.roundInProgress);
  if (preRoundPlayers.every(p => p.ready)) {
    table.autoStartCalled = true;
    gameFlow.autoStart(table);
  }
}

function handlePlayerBet(ws, data) {
  const table = tables[data.tableId];
  if (!table) return;
  const player = table.players.find(p => p.username === data.username);
  if (!player || player.isDealer) return;

  player.currentBet = Number(data.betAmount) || 0;
  const total = table.players.reduce((sum, p) => sum + (p.currentBet || 0), 0);
  broadcastToTable(table.tableId, {
      type: "table:bet:update",
      players: table.players.map(p => ({ username: p.username, betAmount: p.currentBet })),
      total
  });
  wsSend(ws, { type: "game:bet:res", success: true });
}

function handleGameResult(ws, data) 
{
  const body = data.data || data;
  const table = tables[body.tableId];
  if (!table) return;
  const player = table.players.find(p => p.seatId == body.seatId);
  if (player) player.balance += Number(body.updatePoint || 0);
  broadcastToTable(table.tableId, { type: "table:update", tableId: table.tableId, players: table.players });
  wsSend(ws, { type: "game:result:res", success: true });
}

function handlePlayerDrawRequest(ws, data) 
{
  const { tableId, username, action } = data; // action: "draw" or "stop"
  const table = tables[tableId];
  if (!table || !table.watchTimer) return;

  const player = table.players.find(p => p.username === username);
  if (!player) return;

  player.drawAction = action; 
  console.log(`ðŸ“© [ACTION] ${username} wants to ${action}`);
}

function scheduleNextRound(tableId) {
    const table = tables[tableId];
    if (!table || table.waitingForNextRound) return;
    table.waitingForNextRound = true;
    setTimeout(() => {
      [table.countdownInterval, table.betInterval, table.watchTimer, table.findWinnerTimer, table.payoutTimer].forEach(t => t && clearInterval(t));
      table.countdownInterval = table.betInterval = table.watchTimer = table.findWinnerTimer = table.payoutTimer = null;
      resetTableState(table);
      resetPlayersForNextRound(table);
      table.gameInProgress = table.roundInProgress = table.watchTimerStarted = table.dealAckReceived = table.waitingForNextRound = table.autoStartCalled = false;
      table.players.forEach(p => p.ready = true);
      gameFlow.autoStart(table);
    }, 3000);
}
    
function handleDealFinished(ws, data) {
    const { tableId, roundId } = data;
    const table = tables[tableId];
    if (!table || roundId !== table.roundId || table.dealAckReceived) return;
    table.dealAckReceived = true;
    table.watchTimerStarted = true;

    // Reset draw actions for new phase
    table.players.forEach(p => p.drawAction = null);

    const dealer = table.players.find(p => p.isDealer);
    const dealerRes = gameHelpers.calculateShanResult(dealer.cards);

    // 1. Natural 8/9 Check
    if (dealerRes.points >= 8) {
        broadcastToTable(tableId, { type: "game:dealer:natural", points: dealerRes.points });
        return startFindWinnerPhase(tableId, roundId);
    }

    // 2. PHASE 1 START
    let remainingWatch = 5;
    broadcastToTable(tableId, { type: "game:watch:start", seconds: remainingWatch, roundId });
    
    // ðŸ”¥ NEW: Immediately show the panel because Unity just finished the deal animation
    broadcastToTable(tableId, { type: "ui:cardview:show", roundId });
    
    table.watchTimer = setInterval(() => {
        remainingWatch--;
        if (remainingWatch <= 0) {
            clearInterval(table.watchTimer);
            table.watchTimer = null;
            broadcastToTable(tableId, { type: "ui:cardview:hide", roundId });

            processFinalDraws(tableId, roundId);

            const anyoneHasThreeCards = table.players.some(p => !p.waiting && p.cards.length === 3);
            if (anyoneHasThreeCards) {
                startSecondWatchPhase(tableId, roundId);
            } else {
                startFindWinnerPhase(tableId, roundId);
            }
        } else {
            broadcastToTable(tableId, { type: "game:watch:tick", seconds: remainingWatch, roundId });
        }
    }, 1000);
}

function processFinalDraws(tableId, roundId) {
    const table = tables[tableId];
    table.players.forEach(p => {
        if (p.waiting) return;

        const res = gameHelpers.calculateShanResult(p.cards);
        if (res.points >= 8) {
            p.drawAction = "stop"; 
            return; 
        }      
        if (p.isAi && res.points < 4) p.drawAction = "draw";

        // Logic: Manual Draw OR Auto-Draw (< 4 pts)
        if (p.drawAction === "draw" || (!p.drawAction && res.points < 4)) {
            if (p.cards.length === 2) {
                const card = table.deck[table.deckIndex++];
                p.cards.push(card);
                const newRes = gameHelpers.calculateShanResult(p.cards);
                p.points = newRes.points;
                p.multiplier = newRes.payoutMultiplier;

                // Tell everyone to play the 3rd card animation
                broadcastToTable(tableId, { 
                    type: "game:player:draw", 
                    username: p.username, 
                    card: `${card.rank}${{4:"S",3:"H",2:"D",1:"C"}[card.suit]}`,
                    points: p.points
                });

                // ðŸ”¥ DELAYED UI: Wait for 3rd card animation (1.2s) before showing panel
                if (!p.isAi && !p.isDealer && p.ws) {
                    setTimeout(() => {
                        if (p.ws.readyState === 1) {
                            wsSend(p.ws, { type: "ui:cardview:show", roundId });
                            console.log(`âœ¨ [UI] Showed 3rd card panel to ${p.username} after animation delay.`);
                        }
                    }, 1200); 
                }

                const cardLog = p.cards.map(c => `${c.rank}${{4:"S",3:"H",2:"D",1:"C"}[c.suit]}`).join(", ");
                console.log(`ðŸƒ [3RD CARD] ${p.username} | Cards: [${cardLog}] | Points: ${p.points}`);
            }
        }
    });
}

function startSecondWatchPhase(tableId, roundId) {
    const table = tables[tableId];
    let secondWatchTime = 7; 
    
    // Everyone sees the countdown timer
    broadcastToTable(tableId, { type: "game:watch3card:start", seconds: secondWatchTime, roundId });

    const secondTimer = setInterval(() => {
        secondWatchTime--;

        // Trigger the "Peek" UI exactly at 5 seconds remaining
        if (secondWatchTime === 5) {
            table.players.forEach(player => {
                const hasThreeCards = player.cards && player.cards.length === 3;
                const isHumanPlayer = !player.isAi && !player.isDealer;

                // CRITICAL CHECK: Must be human AND have 3 cards
                if (isHumanPlayer && hasThreeCards) {
                    // Send ONLY to this specific player
                    if (player.ws && player.ws.readyState === 1) { 
                        wsSend(player.ws, { type: "ui:cardview:show", roundId });
                        console.log(`âœ¨ [UI] Showing 3rd card panel to ${player.username}`);
                    }
                }
            });
        }

        if (secondWatchTime <= 0) {
            clearInterval(secondTimer);
            // Close the panel for everyone just to be safe
            broadcastToTable(tableId, { type: "ui:cardview:hide", roundId });
            startFindWinnerPhase(tableId, roundId);
        } else {
            broadcastToTable(tableId, { type: "game:watch3card:tick", seconds: secondWatchTime, roundId });
        }
    }, 1000);
}

function startFindWinnerPhase(tableId, roundId) {
    const table = tables[tableId];
    let findWinnerTime = 5;
    broadcastToTable(tableId, { type: "game:findwinner:start", seconds: findWinnerTime, roundId });

    table.findWinnerTimer = setInterval(() => {
        findWinnerTime--;
        if (findWinnerTime <= 0) {
            clearInterval(table.findWinnerTimer);
            const activePlayers = table.players.filter(p => !p.waiting);
            
            // LOG DEALER FINAL STATE
            const dealer = activePlayers.find(p => p.isDealer);
            const dRes = gameHelpers.calculateShanResult(dealer.cards);
            console.log(`DEALER Hand: ${dRes.points} points | Multiplier: x${dRes.payoutMultiplier}`);

            const winnerPlayers = gameHelpers.decideDealerWinners(activePlayers);
            table.currentWinners = winnerPlayers.map(p => p.username || p.name);

            // LOG INDIVIDUAL PLAYER RESULTS
            activePlayers.forEach(p => {
                if (p.isDealer) return;
                const isWinner = table.currentWinners.includes(p.username);
                console.log(`PLAYER ${p.username} ${isWinner ? "WINS" : "LOSES"} with ${p.points} pts (x${p.multiplier || 1})`);
            });

            startPayoutPhase(tableId, roundId);
        } else {
            broadcastToTable(tableId, { type: "game:findwinner:tick", seconds: findWinnerTime, roundId });
        }
    }, 1000);
}

function startPayoutPhase(tableId, roundId) {
    const table = tables[tableId];
    let payoutTime = 5;
    const payoutResults = payoutWinners(table,table.players, table.currentWinners);
    
    // LOG DETAILED MONEY FLOW
    payoutResults.forEach(res => {
        const p = table.players.find(player => player.username === res.username);
        if (p && !p.isDealer) {
            const isWin = table.currentWinners.includes(p.username);
            if (isWin) {
                console.log(`ðŸ’µ WIN â†’ ${p.username} | Bet:${p.currentBet} | x${p.multiplier || 1} | Dealer pays:${res.delta}`);
            }
        }
    });

    broadcastToTable(tableId, { type: "game:payout:result", roundId, results: payoutResults });

    table.payoutTimer = setInterval(() => {
        payoutTime--;
        if (payoutTime <= 0) {
            clearInterval(table.payoutTimer);
            scheduleNextRound(tableId);
        } else {
            broadcastToTable(tableId, { type: "game:payout:tick", seconds: payoutTime, roundId });
        }
    }, 1000);
}

module.exports = { 
    playerReady, 
    handleGameResult, 
    scheduleNextRound, 
    handlePlayerBet, 
    handleDealFinished, 
    handlePlayerDrawRequest 
};