// ===== gameHelpers.js =====

// Import the new Shan evaluation functions
const { evaluateHand, compareHands } = require("./shanRules");// new
const { createDeck, shuffle } = require("./dealCards");
function formatCardsForUnity(cards) {
    const suitMap = { 4: "S", 3: "H", 2: "D", 1: "C" };
    return cards.map(c => `${c.rank}${suitMap[c.suit]}`);
}
/**
 * Get payout multiplier (ဆ) for a hand based on your Shan rules
 * 8, 9 points = 1x
 * 2-card same suit/rank = 2x
 * 3-card same suit = 3x
 * 3-card same rank (Triple) = 5x
 */
function getPayoutMultiplier(hand) {
    return hand.multiplier || 1;
}

/**
 * Calculate Shan result for a single hand
 */
function calculateShanResult(cards) {
    const hand = evaluateHand(cards);

    return {
        cards,
        points: hand.points,
        isDo: hand.isDo, // 8 or 9 on first 2 cards
        multiplier: hand.multiplier,
        powerCard: hand.powerCard,
        canDraw: hand.canDraw, // points < 4
        payoutMultiplier: hand.multiplier
    };
}

/**
 * Unity rank for tie-breaking. 
 * In Shan, points come first, then Power Score (10 > J > Q > K > A), then Suit.
 */
function unityRank(player) {
    const hand = evaluateHand(player.cards);
    // We create a sortable score: (Points * 100) + (Power Score * 10) + SuitValue
    // This allows a simple numeric comparison.
    const suitValue = hand.powerCard.suit; // 4: Spade, 3: Heart, etc.
    const powerScore = getPowerScoreValue(hand.powerCard.rank); 

    return (hand.points * 1000) + (powerScore * 10) + suitValue;
}

// Helper for unityRank (matching your power rules)
function getPowerScoreValue(rank) {
    const powerMap = { 10: 5, 11: 4, 12: 3, 13: 2, 1: 1 };
    return powerMap[rank] || 0;
}

/**
 * Force-generate a hand stronger than a given points/power
 */
function forceWinningHand(minPoints) {
    let attempts = 0;

    while (attempts < 500) {
        const deck = createDeck();
        shuffle(deck);

        const cards = deck.slice(0, 2);
        const hand = evaluateHand(cards);

        if (hand.points > minPoints) {
            return cards; // ONLY 2 CARDS
        }

        attempts++;
    }

    console.warn("⚠️ forceWinningHand fallback triggered");
    return createDeck().slice(0, 2);
}

/**
 * Decide winners against dealer using Shan rules
 */
function decideDealerWinners(players) {
    const dealer = players.find(p => p.isDealer);
    if (!dealer) return [];

    const dealerHand = evaluateHand(dealer.cards);
    const winners = [];

    console.log(`DEALER Hand: ${dealerHand.points} points | Do: ${dealerHand.isDo} | Multiplier: x${dealerHand.multiplier}`);

    players.forEach(p => {
        if (p.isDealer) return;

        const pHand = evaluateHand(p.cards);
        
        // Use the compareHands logic: 1 means player wins, -1 means dealer wins
        const result = compareHands(pHand, dealerHand);

        if (result === 1) {
            winners.push(p);
            console.log(`PLAYER ${p.name} WINS with ${pHand.points} pts (x${pHand.multiplier})`);
        } else {
            console.log(`PLAYER ${p.name} LOSES to dealer`);
        }
    });

    return winners;
}

function buildTableResult(table) {
    return {
        tableId: table.tableId,
        roundId: table.roundId,
        pot: table.players.reduce((sum, p) => sum + (p.currentBet || 0), 0),
        dealer: table.players.find(p => p.isDealer)?.username,
        players: table.players.map(p => {
            const hand = evaluateHand(p.cards);
            return {
                name: p.username,
                isAi: p.isAi,
                seatId: p.seatId,
                unit: p.balance,
                cards: formatCardsForUnity(p.cards),
                points: hand.points,
                isDo: hand.isDo,
                multiplier: hand.multiplier,
                isDealer: p.isDealer
            };
        })
    };
}


module.exports = {
    evaluateHand,
    unityRank,
    forceWinningHand,
    decideDealerWinners,
    calculateShanResult,
    buildTableResult 
};