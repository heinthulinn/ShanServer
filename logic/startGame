// ===== startGame.js =====
const { tables } = require("../state/tables");
const { broadcastToTable } = require("../ws/sender");
const { targetRTP } = require("../config/rtp");
const { createDeck, shuffle, createDealer } = require("./dealCards");
const { evaluateRTP, recordPayout } = require("./rtp");
const { collectBets, payoutWinners } = require("./payout");
const gameHelpers = require("./gameHelpers");

function startGame(ws, data) {
    const tableId = data.tableId;
    const table = tables[tableId];
    if (!table) return;

    // ===============================
    // ðŸ”„ ROUND RESET
    // ===============================
    table.roundId += 1;
    table.dealAckReceived = false;
    table.watchTimerStarted = false;

    if (table.watchTimer) {
        clearTimeout(table.watchTimer);
        table.watchTimer = null;
    }

    table.currentWinners = [];
    table.roundState.inProgress = true;
    table.roundState.startedAt = Date.now();
    table.gameInProgress = true;

    console.log(`ðŸŒ€ SHAN ROUND STARTED | table=${tableId} | roundId=${table.roundId}`);

    // --- Build active players ---
    let players = table.players
        .filter(p => !p.waiting)
        .map(p => ({
            name: p.username,
            isAi: p.isAi,
            seatId: p.seatId,
            unit: p.balance,
            bet: Number(p.currentBet) || 0,
            cards: null,
            isDealer: p.isDealer,
            hand: null
        }));
    
    const roundTotalBet = players.reduce((sum, p) => sum + p.bet, 0);
    const activePlayerCount = players.filter(p => p.bet > 0).length;

    // --- RTP Init ---
    const rtp = table.rtpStats;
    const { pot, bias, actualRTP } = evaluateRTP(rtp, roundTotalBet, activePlayerCount, targetRTP);

    // --- Shuffle & Deal (SHAN START: 2 CARDS) ---
    const deck = createDeck();
    shuffle(deck);
    
    // We use a simple slice for 2 cards each
    let deckIndex = 0;
    players.forEach(p => {
        // Deal exactly 2 cards for the start of Shan Koe Mee
        p.cards = deck.slice(deckIndex, deckIndex + 2);
        deckIndex += 2;
        p.hand = gameHelpers.evaluateHand(p.cards);
    });

    broadcastToTable(tableId, { type: "game:deal:finished" });

    // --- Apply RTP Bias (Pot=2: Real Player Advantage) ---
    const realPlayers = players.filter(p => !p.isAi);
    const aiPlayers = players.filter(p => p.isAi);

    if (pot === 2 && realPlayers.length && aiPlayers.length) {
        // Find best AI points to beat
        const bestAIPoints = Math.max(...aiPlayers.map(p => p.hand.points));
        
        const targetReal = realPlayers.reduce((a, b) =>
            a.hand.points > b.hand.points ? a : b
        );

        // Force a winning 2-card hand for the real player
        targetReal.cards = gameHelpers.forceWinningHand(bestAIPoints);
        targetReal.hand = gameHelpers.evaluateHand(targetReal.cards);

        console.log(`ðŸ”¥ RTP Bias: Forced win for ${targetReal.name}`);
    }

    // --- Decide winners against Dealer ---
    const winnerPlayers = gameHelpers.decideDealerWinners(players);
    const winners = winnerPlayers.map(p => p.name);
    table.currentWinners = winners;

    // --- Calculate Multipliers and Results ---
    players.forEach(p => {
        // We call calculateShanResult (the function we created in gameHelpers)
        const result = gameHelpers.calculateShanResult(p.cards);
        p.multiplier = result.payoutMultiplier;
        p.points = result.points;
    });

    // ðŸ”„ Sync updated info back to table.players
    table.players.forEach(tp => {
        const p = players.find(pl => pl.name === tp.username);
        if (p) {
            tp.cards = p.cards;
            tp.isDealer = p.isDealer;
            tp.currentBet = p.bet;
            tp.multiplier = p.multiplier;
            tp.points = p.points;
        }
    });

    if (winnerPlayers.length > 0) {
        payoutWinners(table.players, winners, roundTotalBet);
        recordPayout(rtp, roundTotalBet);
    }

    // --- Prepare final payload ---
    const playersInRound = players.map(p => ({
        name: p.name,
        isAi: p.isAi,
        seatId: p.seatId,
        unit: p.unit,
        cards: p.cards,
        points: p.points,
        isDealer: p.isDealer
    }));

    const dealerPlayer = playersInRound.find(p => p.isDealer);
    const final = {
        type: "game:start:result",
        tableId,
        roundId: table.roundId,
        pot,
        dealer: dealerPlayer ? dealerPlayer.name : null,
        players: playersInRound,
        winners,
        rtp: { target: targetRTP, actual: actualRTP.toFixed(3), bias }
    };

    broadcastToTable(tableId, final);
}

module.exports = { startGame };