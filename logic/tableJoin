const { tables } = require("../state/tables");
const { validUsers } = require("../state/users");
const { wsSend, broadcastToTable } = require("../ws/sender");
const { assignBaseAiFirst } = require("./tableHelpers");
const { hardResetTable } = require("./roundReset");
const { buildGameStateSnapshot } = require("./tableSnapshot");

function hasStaleTableState(table) {
  return Boolean(
    table.roundInProgress ||
    table.gameInProgress ||
    table.joinLockedForRound ||
    table.waitingForNextRound ||
    table.dealAckReceived ||
    table.watchTimerStarted ||
    table.isProcessingResult ||
    table.autoStartCalled ||
    table.countdownInterval ||
    table.betInterval ||
    table.watchTimer ||
    table.findWinnerTimer ||
    table.payoutTimer ||
    table.currentWinners?.length
  );
}

function shouldJoinAsWaiting(table) {
  if (!table.roundInProgress) return false;
  return !!table.joinLockedForRound;
}

function serializeTablePlayers(table) {
  return table.players.map(p => ({
    seatId: p.seatId,
    username: p.username,
    balance: p.balance,
    isAi: p.isAi,
    ready: p.ready,
    waiting: p.waiting
  }));
}

function leaveTable(ws, d = {}) {
  const tableId = d.tableId || ws.tableId;
  const username = d.username || ws.username;
  const isDisconnect = !!d.isDisconnect;

  if (!tableId || !username) {
    if (!isDisconnect) {
      wsSend(ws, {
        type: "tables:leave:res",
        success: false,
        error: "Missing tableId or username"
      });
    }
    return;
  }

  const table = tables[tableId];
  if (!table) {
    if (!isDisconnect) {
      wsSend(ws, {
        type: "tables:leave:res",
        success: false,
        tableId,
        error: "Table not found"
      });
    }
    return;
  }

  const hadPlayer = table.players.some(p => p.username === username && !p.isAi);
  table.players = table.players.filter(p => p.username !== username);

  if (ws && ws.tableId === tableId && ws.username === username) {
    ws.tableId = null;
    ws.username = null;
  }

  if (!hadPlayer && !isDisconnect) {
    wsSend(ws, {
      type: "tables:leave:res",
      success: false,
      tableId,
      error: "User not at this table"
    });
    return;
  }

  if (table.players.filter(p => !p.isAi).length === 0) {
    console.log(`üßπ Table ${tableId} empty ‚Üí clearing AI & resetting state`);
    hardResetTable(table);
    broadcastToTable(tableId, {
      type: "table:reset",
      tableId
    });
  }

  broadcastToTable(tableId, {
    type: "table:update",
    tableId,
    players: serializeTablePlayers(table)
  });

  if (!isDisconnect) {
    wsSend(ws, {
      type: "tables:leave:res",
      success: true,
      tableId
    });
  }
}

function joinTable(ws, d) {
  const u = validUsers.find(x => x.username === d.username);
  if (!u) {
    return wsSend(ws, {
      type: "tables:join:res",
      success: false,
      error: "Invalid user"
    });
  }

  const table = tables[d.tableId];
  if (!table) {
    return wsSend(ws, {
      type: "tables:join:res",
      success: false,
      error: "Table not found"
    });
  }

  const realPlayersCountBeforeJoin = table.players.filter(p => !p.isAi).length;
  if (realPlayersCountBeforeJoin === 0 && hasStaleTableState(table)) {
    console.log(`üõ† Defensive reset on join for ${table.tableId} (stale state detected)`);
    hardResetTable(table);
  }

  const alreadyJoined = table.players.find(
    p => p.username === u.username && !p.isAi
  );
  if (alreadyJoined) {
    return wsSend(ws, {
      type: "tables:join:res",
      success: false,
      error: "User already joined this table"
    });
  }

  assignBaseAiFirst(table);

  const realPlayersCount = table.players.filter(p => !p.isAi).length;
  if (realPlayersCount >= 4) {
    return wsSend(ws, {
      type: "tables:join:res",
      success: false,
      error: "Table already has maximum real players"
    });
  }

  const usedSeats = table.players.map(p => p.seatId);
  let seatId = 1;
  while (usedSeats.includes(seatId)) seatId++;

  const newPlayer = {
    username: u.username,
    token: u.token,
    balance: u.balance,
    seatId,
    isAi: false,
    ready: false,
    waiting: shouldJoinAsWaiting(table),
    socketId: ws._socket?.remotePort
  };

  table.players.push(newPlayer);
  ws.tableId = table.tableId;
  ws.username = u.username;

  // 1Ô∏è‚É£ join confirm (Unity relies on this)
  wsSend(ws, {
    type: "tables:join:res",
    success: true,
    result: {
      tableId: table.tableId,
      tableName: table.tableName,
      assignedSeat: seatId,
      gameInProgress: table.gameInProgress,
      joinLocked: !!table.joinLockedForRound
    }
  });

  // 2Ô∏è‚É£ full snapshot
  wsSend(ws, {
    type: "table:full:update",
    tableId: table.tableId,
    gameInProgress: table.gameInProgress,
    joinLocked: !!table.joinLockedForRound,
    players: table.players.map(p => ({
      seatId: p.seatId,
      username: p.username,
      balance: p.balance,
      isAi: p.isAi,
      ready: p.ready,
      waiting: p.waiting
    }))
  });

  if (table.roundInProgress) {
    wsSend(ws, buildGameStateSnapshot(table));
  }

  // 3Ô∏è‚É£ notify others
  broadcastToTable(table.tableId, {
    type: "table:update",
    tableId: table.tableId,
    players: serializeTablePlayers(table)
  });
}

module.exports = { joinTable, leaveTable };
