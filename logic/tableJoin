const { tables } = require("../state/tables");
const { validUsers } = require("../state/users");
const { wsSend, broadcastToTable } = require("../ws/sender");
const { assignBaseAiFirst } = require("./tableHelpers");
const { hardResetTable } = require("./roundReset");

function hasStaleTableState(table) {
  return Boolean(
    table.roundInProgress ||
    table.gameInProgress ||
    table.waitingForNextRound ||
    table.dealAckReceived ||
    table.watchTimerStarted ||
    table.isProcessingResult ||
    table.autoStartCalled ||
    table.countdownInterval ||
    table.betInterval ||
    table.watchTimer ||
    table.findWinnerTimer ||
    table.payoutTimer ||
    table.currentWinners?.length
  );
}

function joinTable(ws, d) {
  const u = validUsers.find(x => x.username === d.username);
  if (!u) {
    return wsSend(ws, {
      type: "tables:join:res",
      success: false,
      error: "Invalid user"
    });
  }

  const table = tables[d.tableId];
  if (!table) {
    return wsSend(ws, {
      type: "tables:join:res",
      success: false,
      error: "Table not found"
    });
  }

  const realPlayersCountBeforeJoin = table.players.filter(p => !p.isAi).length;
  if (realPlayersCountBeforeJoin === 0 && hasStaleTableState(table)) {
    console.log(`ðŸ›  Defensive reset on join for ${table.tableId} (stale state detected)`);
    hardResetTable(table);
  }

  const alreadyJoined = table.players.find(
    p => p.username === u.username && !p.isAi
  );
  if (alreadyJoined) {
    return wsSend(ws, {
      type: "tables:join:res",
      success: false,
      error: "User already joined this table"
    });
  }

  assignBaseAiFirst(table);

  const realPlayersCount = table.players.filter(p => !p.isAi).length;
  if (realPlayersCount >= 4) {
    return wsSend(ws, {
      type: "tables:join:res",
      success: false,
      error: "Table already has maximum real players"
    });
  }

  const usedSeats = table.players.map(p => p.seatId);
  let seatId = 1;
  while (usedSeats.includes(seatId)) seatId++;

  const newPlayer = {
    username: u.username,
    token: u.token,
    balance: u.balance,
    seatId,
    isAi: false,
    ready: false,
    waiting: table.gameInProgress,
    socketId: ws._socket?.remotePort
  };

  table.players.push(newPlayer);
  ws.tableId = table.tableId;
  ws.username = u.username;

  // 1ï¸âƒ£ join confirm (Unity relies on this)
  wsSend(ws, {
    type: "tables:join:res",
    success: true,
    result: {
      tableId: table.tableId,
      tableName: table.tableName,
      assignedSeat: seatId,
      gameInProgress: table.gameInProgress
    }
  });

  // 2ï¸âƒ£ full snapshot
  wsSend(ws, {
    type: "table:full:update",
    tableId: table.tableId,
    gameInProgress: table.gameInProgress,
    players: table.players.map(p => ({
      seatId: p.seatId,
      username: p.username,
      balance: p.balance,
      isAi: p.isAi,
      ready: p.ready,
      waiting: p.waiting
    }))
  });

  // 3ï¸âƒ£ notify others
  broadcastToTable(table.tableId, {
    type: "table:update",
    tableId: table.tableId,
    players: table.players.map(p => ({
      seatId: p.seatId,
      username: p.username,
      balance: p.balance,
      isAi: p.isAi,
      ready: p.ready,
      waiting: p.waiting
    }))
  });
}

module.exports = { joinTable };
